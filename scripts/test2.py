import asyncio
import json
import re
import struct
from anchorpy import Program, Provider, Wallet, Idl
from solana.rpc.api import Client
from solana.publickey import PublicKey
from solana.keypair import Keypair
from offchain.functions import hash_b, sign_hash
from offchain.KeyTracker_ import KeyTracker
from eth_abi import encode
from time import sleep
from web3 import Web3
from web3.exceptions import InvalidAddress

oracle_pkh = []
master_pkh_1 = []
master_pkh_2 = []
master_pkh_3 = []
master_pkh_4 = []

def load_keypair():
    """ Load or generate a new keypair for testing """
    # try:
    with open('../id.json', 'r') as f:
        keypair = Keypair.from_secret_key(bytes(json.load(f)))
    # except FileNotFoundError:
    #     keypair = Keypair.generate()
    #     with open('path_to_your_keypair.json', 'w') as f:
    #         json.dump(list(keypair.secret_key), f)
    return keypair
def main():
    for _ in range(1):  # This will repeat the whole logic 3 times
        lamport_test = LamportTest()
        
        # Convert all account objects to strings before passing them
        lamport_test.can_test_key_functions([str(acc) for acc in accounts])

class LamportTest:
    
    async def __init__(self):

        # Load the IDL generated by Solang compiler
        with open("../target/idl/LamportBase2.json", "r") as f:
            idl = Idl.from_json(json.load(f))

        # Setup the client to the devnet
        client = Client("https://api.devnet.solana.com")

        # Load your wallet keypair
        wallet = Wallet(load_keypair())

        # Create a provider with the client and wallet
        provider = Provider(client, wallet)

        # Define the program ID and create a Program object
        program_id = PublicKey("8eovpQdggxgAk2LvxHyKdNvrH48eAipMSryXSETuYFqx")
        program = Program(idl, program_id, provider)

        # Example of making a contract call, replace `function_name` with your function
        # and set appropriate parameters
        try:
            tx = await program.rpc["function_name"](param1, param2, {
                "accounts": {
                    "account_to_interact": PublicKey("Relevant_Account_Public_Key"),
                    # other accounts needed by the function
                },
                "signers": [wallet.payer]  # if needed
            })
            print("Transaction signature:", tx)
        except Exception as e:
            print("Error executing transaction:", e)
    
    def can_test_key_functions(self, accs):
        global master_pkh_1
        global master_pkh_2
        global master_pkh_3
        global master_pkh_4
        print("Running 'can_test_key_functions'...")
        with open('contract_AnonID.txt', 'r') as file:
            contract_address = file.read()
            contract_address = contract_address.strip().replace('\n', '')  # Remove whitespace and newlines

        _contract = AnonIDContract.at(contract_address)
        print("Contract referenced.")
        print('master_pkh_3', master_pkh_3)
        private_key = '163f5f0f9a621d72fedd85ffca3d08d131ab4e812181e0d30ffd1c885d20aac7'
        brownie_account = accounts.add(private_key)
        current_keys = self.k4.load(self, "master3", master_pkh_1)
        current_pkh = self.k4.pkh_from_public_key(current_keys.pub)
        print('current pkh', current_pkh)
        next_keys = self.k4.get_next_key_pair()
        nextpkh = self.k4.pkh_from_public_key(next_keys.pub)
        #pairs = generate_address_value_pairs(10)
        #packed_pairs = solidity_pack_pairs(pairs)
        #_newCap = int(300000)
        #numToBroadcast = int(1000000)
        #pnumToBroadcast = numToBroadcast.to_bytes(4, 'big')
        #paddednumToBroadcast = solidity_pack_value_bytes(pnumToBroadcast)
        #paddressToBroadcast = '0x99a840C3BEEe41c3F5B682386f67277CfE3E3e29' # activity contract needing approval
        with open('contract_PlayerDatabase-coin.txt', 'r') as file:
            contract_address2 = file.read()
            contract_address2 = contract_address2.strip().replace('\n', '') 
        paddressToBroadcast = contract_address2
        packed_message = str.lower(paddressToBroadcast)[2:].encode() + nextpkh[2:].encode()

        callhash = hash_b(str(packed_message.decode()))
        sig = sign_hash(callhash, current_keys.pri) 
        private_key = '163f5f0f9a621d72fedd85ffca3d08d131ab4e812181e0d30ffd1c885d20aac7'
        brownie_account = accounts.add(private_key)
    
        def can_test_key_functions(self, accs):
        global master_pkh_1
        global master_pkh_2
        global master_pkh_3
        global master_pkh_4
        print("Running 'can_test_key_functions'...")
        with open('contract_AnonID.txt', 'r') as file:
            contract_address = file.read()
            contract_address = contract_address.strip().replace('\n', '')  # Remove whitespace and newlines

        _contract = AnonIDContract.at(contract_address)
        print("Contract referenced.")
        print('master_pkh_3', master_pkh_3)
        private_key = '163f5f0f9a621d72fedd85ffca3d08d131ab4e812181e0d30ffd1c885d20aac7'
        brownie_account = accounts.add(private_key)
        current_keys = self.k4.load(self, "master3", master_pkh_1)
        current_pkh = self.k4.pkh_from_public_key(current_keys.pub)
        print('current pkh', current_pkh)
        next_keys = self.k4.get_next_key_pair()
        nextpkh = self.k4.pkh_from_public_key(next_keys.pub)
        #pairs = generate_address_value_pairs(10)
        #packed_pairs = solidity_pack_pairs(pairs)
        #_newCap = int(300000)
        #numToBroadcast = int(1000000)
        #pnumToBroadcast = numToBroadcast.to_bytes(4, 'big')
        #paddednumToBroadcast = solidity_pack_value_bytes(pnumToBroadcast)
        #paddressToBroadcast = '0x99a840C3BEEe41c3F5B682386f67277CfE3E3e29' # activity contract needing approval
        with open('contract_PlayerDatabase-coin.txt', 'r') as file:
            contract_address2 = file.read()
            contract_address2 = contract_address2.strip().replace('\n', '') 
        paddressToBroadcast = contract_address2
        packed_message = str.lower(paddressToBroadcast)[2:].encode() + nextpkh[2:].encode()

        callhash = hash_b(str(packed_message.decode()))
        sig = sign_hash(callhash, current_keys.pri) 
        private_key = '163f5f0f9a621d72fedd85ffca3d08d131ab4e812181e0d30ffd1c885d20aac7'
        brownie_account = accounts.add(private_key)
# # Run the main function using asyncio
# if __name__ == "__main__":
#     asyncio.run(main())
